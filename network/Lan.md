### IP와 이더넷의 패킷 송 * 수신 동작

- MAC헤더는 서브넷에서 이동할 때 사용 되는 것이다.
- IP헤더는 그외의 구간에서 이동할 때에 사용 되는 것이다.
- 클라이언트에서 제일 가까운 라우터에 대한 정보를 MAC헤더에 기록한다. 예를들어 R1이라고 하자
- 그러면 서브넷에 있는 허브에게 간다. 만약 복수라면 허브를 순차적으로 경유한다.
- 허브는 MAC 헤더와 자신이 기록하고 있는 표랑 같이 모아서 목적지를 판단해서 중계한다.
- 패킷이 다음 라우터에 도착한다.
- 라우터에는 IP 용 표가 있으므로 이것을  IP헤더가 읽어서 어느 라우터에 패킷을 중계하면 좋을지를 결정한다.
- 그리고 다음 라우터의 목적지를 알아야 되니까  MAC헤더에 다시 기록한다.
- 그렇기 떄문에 MAC헤더는 계속 업데이트 되는 꼴이다.
- 역할을 분담하는 이유 : 이더넷 같은 것은 다른 것으로 대체될 수가 있다. (무선  LAN, ADSL 등) 그래서 유연성이 필요하다.
- 하나의  PC에 LAN 어댑터는 여러개가 될 수 있다.
- IP주소 할당은 LAN 어댑터 별로 부여가 되기 떄문에 하나의 PC가 여러개의 IP를 가질 수 있다!!
- 송신처의 IP주소는 송신처가 되는 LAN 어댑터를 판단하여 주소를 설정한다.
- MAC 주소는 48비트
- MAC주소도 송신처와 수신처가 존재하는 데, 수신처는 'Gateway' 항목에 기록되어 있는 IP주소의 기기가 패킷을 건네줄 상대가 된다.
- 여기서 사용되는 것이 'ARP' 인데 이더넷에 연결되어 있는 전원에게 패킷을 전달하는 브로드캐스트 구조가 있으며 이 구조를 이용하여 "00 라는 IP주소를 가지고 있는 분 있습니까?" 라고 물어보면 해당자가"저요! 제 MAC주소는 XXXX입니다" 라고 응답을 해준다.
- 브로드 캐스트로 조사하게 되면 ARP는 ARP 캐시를 이용해 메모리 영역에 보존하여 다시 이용한다.
- ARP로 수신처 라우터의 MAC 주소를 조사한다.

### 이더넷의 기본

- IP담당 부분이 패킷을 완성했으면 LAN 어댑터가 나설 차례다.
- 이더넷에서는 네트워크 전체에 신호가 흐르고 그 신호의 대상이 되는 대상만 패킷을 수신하고 나머지는 패킷을 폐기합니다.
- 스위칭 허브는 수신처 MAC주소에 따라 목적지를 확인하고 패킷을 중계하므로 신호는 원하는 상대에게만 흐릅니다.
- 이더넷의 송* 수신 동작은 TCP 동작 단계에 상관없이 모든 것에 공통이다.

IP 패킷을 전기나 빛의 신호로 변환하여 송신한다.

- IP가 만든 패킷은 디지털 데이터이므로 이것을 전기나 빛의 신호로 변환하여 송신한다.!
- 이 동작을 실행하는 것이 LAN 어댑터 이다.
- LAN 어댑터는 전원을 공급하면 바로 작동하는 것이 아니라 초기화 작업을 거쳐야 한다.
- LAN 어댑터 안에는 이더넷 송* 수신을 담당하는 MAC이라는 것이 있는 데 거기에 MAC주소를 설정하는 것이 초기화 작업 중 하나이다.
- 그냥 간단하게 LAN 어댑터가 있는데 그 안에서 초기화 작업을 해서 MAC주소를 등록하는 것이다.
- 이제 패킷에 3개의 제어용 데이터를 추가한다!!
    1. 프리앰블 : 송신하는 패킷을 읽을 때의 타이밍을 잡기 위한 것 1과 0이 번갈아 나타나는 56비트이다. 
    2. 스타트 프레임 딜리미터 : 패킷의 시작을 나타내는 표시
    3. 프레임 체크 시퀀스(FCS) : 패킷을 운반하는 도중에 잡음 등의 영향으로 파형이 흐트러져 데이터가 변한 경우 이것을 검출하기 위해 사용한다. 패킷을 운반하는 도중 잡음 등의 영향으로 내용의 데이터가 변하면 수신측에서 계산한 FCS가 송신할 때 계산한 것과 다른 값이 된다. 그래서 이러한 불일치로 데이터가 변화한 사실을 검출한다. 
- 디지털 데이터를 전기신호로 변화 시킬 때에는 0과 1을 전압이나 전류의 값에 대응시킵니다.
- 이제 101010 등으로 시놓가 가게되는데, 만약에 000000으로가면 파형이 똑같기떄문에 0을 어디까지의 0인지 구분을 할 수가 없어진다 그렇기 때문에 클록신호라는 것을 같이 보낸다.
- 그런데 또 문제가 있다. 케이블이 길어지면 신호선의 길이가 달라져서 데이터 신호와 클록 신호가 전달되는 시간에 차이가 생기기 때문에 클록이 틀어져 버린다..
- 그래서 클록 신호와 데이터 신호를 합치면 문제를 해결할 수 있다.
- 그런데 이 때 클록 신호의 타이밍을 판단하는 것이 중요한 데 , 10 메가비트/초나 100메가비트/ 초라는 식으로 클록이 변화하는 주기는 결정되어 있으므로 에스컬레이터를 탈 떄에 타이밍을 맞추는 것 처럼 잠시 신호를 볼 수 있으면 타이밍을 파악할 수 있다.
- 클록 신호의 타이밍을 잡기위해 특별한 신호를 패킷 앞에 부가하게 되는 데 이것이 프리앰블의 역할이다.
- 스타트 프레임 딜리미터가 패킷의 시작을 나타내는 표시가 된다.

### 허브를 향해 패킷을 송신한다.

- 반이중 모드 : 케이블에 다른 기기가 송신한 신호가 흐르고 있는지 조사하고, 신호가 흐르고 있으면 그것이 끝날 때 까지 기다린다. 신호가 흐르고 있을 때 송신 동작을 시작하면 신호가 충돌하기 때문, 신호가 정지했거나 신호가 안흐르면 송신동작을 한다.
- 송신동작 : 디지털 데이터를 전기신호로 프리앰블부터 변환을 한다.
- 디지털 데이터를 신호로 변환하는 속도가 전송 속도이다.
- LAN 어댑터의 MAC회로가 공통 형식의 신호를 만들고 PHY(MAU) 회로가 케이블에 송출하는 형식으로 변환하여 케이블에 송신합니다.
- 이더넷은 송신한 신호가 상대에게 완전하게 도착했는지 확인하지 않는다. 이더넷은 길이를 보통 100m이내로 정하는데 길어야 100m이므로 오류가 좀처럼 발생하지 않지만, 오류가 발생하면 프로토콜 스택의 TCP가 검출하므로 송신할 때 오류를 확인할 필요가 없다.
- 만약에 송신 중에 또다른 신호가 발견되면 다른 기기에 알리기 위해 재밍 신호라는 특수한 신호를 잠시 동안 흘리고 나서 송신 동작을 멈추고 다시 기다렸다가 다시 한번 송신 동작을 시도한다.
- 재신호를 보냈는 데 또 충돌이 나면 대기시간을 2배로 늘려서 재송신한다.
- 수신 측은 프리앰블부터 FCS까지 전기신호를 디지털 신호로 바꿔서 해석하고 FCS가 바뀐것이 아닌지 확인한다. 그 이후 MAC주소를 확인하여 자신에게 온 패킷인지 확인하고 자신에게 온 패킷이 아니라면 폐기한다.
- 만약 자신에게 온 패킷이면 버퍼메모리에 저장한다.
- 패킷이 왔다는 것을 컴퓨터에 통지하는 것은 인터럽트 라는 구조를 사용한다.
- 컴퓨터는 패킷을 해석하는 그런 역할은 랜 어댑터가 하기 때문에 자신에게 패킷이 온지를 모른다. 그래서 컴퓨터 본체가 실행하고 있는 작업에 끼어들어 LAN 어댑터쪽에 주의시키는 것이 인터럽트이다.
- LAN 어댑터가 확장 버스 슬롯 구분에 있는 인터럽트용 신호선에 신호를 보낸다. 이 신호선은 컴퓨터 본체측의 인터럽트 컨트롤러를 통해 CPU에 연결되어 있다. 신호가 들어오면 일시적으로 보류하고 OS내부의 인터럽트 처리용 프로그램 쪽으로 전환한다.
- 여기서  LAN 드라이버가 호출되어 LAN 어댑터를 제어하면서 송 수신 동작을 실행한다.
- ICMP : 스위칭허브같은 중계 장치가 아닌데 자신이 수신한 패킷을 IP 담당영역에서 수신처의 IP주소를 봤을 때에, 자신의 주소와 일치하지 않으면  ICMP 로 통신 상대에게 오류를 통지하게 되어있다.
- 분할된 패킷은  IP헤더에 있는 플래그라는 항목을 보면 알 수 있다.
- 분할된 패킷을 원래의 모습으로 되돌리는 동작은 리어셈블링 이라고 한다.
- 이제 TCP에서 TCP 헤더에 있는 송신처 IP주소, 수신처  IP주소 , 수신처 포트 및 송신처 포트 4가지를 확인하고 그것에 해당하는 소켓을 찾습니다. 데이터가 만약에 있다면 수신버퍼에 저장하고 애플리케이션에서 그것을 가져가길 기다리고 단순 커넥션 연결같은 제어용 애플리케이션이면 제어용 패킷을 반손하거나 접속 및 연결끊기 등을 실행한다.

### UDP 프로토콜을 이용한 송 * 수신 동작

### 수정 송신이 필요없는 데이터의 송신은 UDP가 효율적이다.

- TCP가 복잡한 이유는 데이터가 손실되었을 떄에 해당 데이터만 따로 보내야 되기 떄문인데, 만약 패킷하나에 들어갈 만큼 데이터의 크기가 작다면 굳이 복잡하게 TCP를 사용해야 할 이유가 없다.
- 패킷하나가 잘못보내졌다고 하면 그거 하나만 보내면 되기 때문이다.
- 무언가 데이터를 보내면 회신이 돌아온다.
- 그래서 DNS 서버에 대한 조회 등 제어용으로 실행하는 정보 교환은 한 개의 패킷으로 끝나는 경우가 많으므로 UDP를 사용한다 .
- 접속이나 연결 끊기 단계가 없다.
- 회답이 돌아오지 않으면 애플리케이션이 그걸 알아차리고 데이터를 한 번 더 보내면 그만이다.

### 음성 및 동영상 데이터

- 음성 및 동영상 데이터는 데이터 도착이 지연되면 타이밍이 안 맞아서 쓸모가 없다.
- 그래서 TCP로 데이터를 다시 보낸다고 해도 쓸모가 없다.. 그래서 UDP가 최고다.
- 정  TCP를 사용하고 싶다면 매우 빠른 고속회선을 사용하면 되긴한다.