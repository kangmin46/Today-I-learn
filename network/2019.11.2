## 1장 JPA 란?

- JPA의 성과 : 애플리케이션을 SQL이 아닌 객체 중심으로 설계할 수가 있다. 그래서 유지보수가 편해진다.
- 테스트를 작성하기도 편해졌다고 한다.
- 과거에는 데이터베이스 설계를 하면 객체설계를 잘 하지 못하고 데이터베이스 설계에 맞춰야 되서 객체지향적이지 못했다고 한다.
- 자바로 작성한 애플리케이션은  JDBC API로 SQL을 데이터베이스에 전달한다.
- JDBC 를 사용할 때의 개발 순서
    1. SQL을 작성한다.
    2. JDBC API를 사용해서   SQL을 실행한다.
    3. 조회 결과를 객체에 매핑한다. 
- 이럴 떄의 문제점...
- 객체의 필드가 추가되게 되면 쿼리문도 바뀌게 된다.
- 엔티티 : 비즈니스 요구사항을 모델링한 객체를 엔티티라고 한다.
- persist() 메소드는 JPA가 객체와 매핑정보를 보고 적절한 insert sql을 생성해서 데이터베이스에 전달한다.
- 매핑정보는 어떤 객체를 어떤 테이블에 관리할지 정의한 정보다.
- 데이터베이스는 상속, 추상화 같은 것이 없고 데이터베이스가 지향하는 바는 자바와 다르다.
- 그래서 이러한 패러다임 불일치를 해결해야 한다.
- 연관관계에서도 패러다임 불일치가 생겨난다.
- 예를들어 자바에서는 Member라는 클래스에 team이라는 필드를 가지고 있어야 참조가 가능하고 team 에서는 Member를 모르는 상황인데, 데이터베이스 에서는 테이블에서  FK만 가지고 있다면 양방향으로 참조가 가능하다.
- SQL을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는 지 정해진다.
    - 객체에서는 다른 객체를 탐색할 떄 이렇게한다 :

        member.getOrder().getOrderItem()...

    - 그런데 DB를 조회해서 나온 객체가 참조하고 있는 객체를 마음껏 참조할 수 있을까?? 쿼리를 날려보면

        select M.*, T.* from member M join team T on M.TEAM_ID = T.TEAM_ID

    - 이렇게 하면 member.getOrder() 는 null이 나온다..
- JPA는 이것을 지연로딩 이라는 것으로 해결한다.
- 동일성 비교와 동등성 비교
    - 동일성 비교는 == 비교다. 객체 인스턴스의 주소값을 확인한다.
    - 동등성 비교는 equals() 메소드를 사용해서 객체 내부의 값을 비교한다.
- JPA는 어쩃든 JDBC API를 사용하고 있다.
- JPA중에 하이버네이트 프레임워크가 패러다임 불일치를 제일 잘 해결해주는 성숙한 프레임워크다.

## 2장 jpa 시작
- H2 는 자바가 설치되어 있어야 동작한다.
- 매핑 어노테이션을 생략하면 필드명을 사용해서 칼럼명으로 매핑한다.
- JPA 어노테이션의 패키지는 javax.persistence이다.
- 메이븐에서는 persistence.xml이 META-INF/persistence.xml 클래스 패스경로에 있으면  JPA가 인식할 수 있다.
- 엔티티 매니저 팩토리 : 엔티티 매니저를 만들어 주는 역할이다. 애플리케이션에서 1개만 있어야되고 여러 스레드가 공유해야 된다.
- 엔티티 매니저 : 엔티티 매니저 팩토리가 만들어주는 아이다. 애플리케이션 개발자는 엔티티 매니저를 가상의 데이터베이스로 생각할 수 있다. 엔티티 매니저는 데이터베이스 커넥션과 관계가 있으므로 스레드간에 공유하거나 재사용하면 안된다.
- JPA 를 사용하면 트랜잭션 안에서 데이터를 변경해야 한다. 트랜잭션 없이 데이터를 변경하면 예외가 발생한다. 트랜잭션을 시작하려면 엔티티 매니저에서 트랜잭션 API를 받아와야 한다.
- JPA는 JPQL이라는 추상화된 쿼리언어를 지원하는 데, 이것은 SQL과 조금 다르다.
- SQL은 select 할 때에 테이블이름을 적지만, JPQL은 엔티티이름을 적는다.

## 3.1 엔티티 매니저 팩토리와 엔티티 매니저

- 엔티티 매니저는  DB연결이 꼭 필요한 시점까지 커넥션을 얻지 않는다.  예를들어 트랜잭션을 시작할 때에 커넥션을 획득한다.
- persist() 메소드는 엔티티 매니저를 사용해서 엔티티를 영속성 컨택스트에 저장한다.
- 준영속 상태 : em.detach(), em.close(), em.clear()를 호출해서 영속성 컨텍스트를 초기화 해도 영속성 컨텍스트가 관리하던 영속 상태의 엔티티는 준영속 상태가 된다.

## 3.2 영속성 컨텍스트의 특징

- 영속 상태는 식별자 값이 반드시 있어야 한다.
- 영속성 컨텍스트는 엔티티를 식별자 값으로 구분한다.
- 영속성 컨텍스트는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 DB에 반영하는데 이것이  Flush()다.
- 영속성 컨텍스트의 장점
    1. 1차캐시
    2. 동일성 보장
    3. 트랜잭션을 지원하는 쓰기 지연
    4. 변경 감지
    5. 지연 로딩
- 영속성 컨텍스트는 내부네 캐시를 가지고 있는 데 이것을 1차캐시라 한다.
- 일단 persist()하면 엔티티는 1차캐시에 저장된다.
- em.find() 를 호출하면 일단 1차캐시를 살펴보고 1차캐시에 있으면 DB를 조회하지 않고 메모리에 있는 1차 캐시에서 엔티티를 조회한다.
- 1차 캐시에 없으면 DB를 조회해서 엔티티를 반환한다.
- 자 근데 여기서 중요한 점
    - 만약 1차캐시에 없는 엔티티를 조회할 경우 DB를 조회해서 엔티티를 반환한다고 했는데 이 때 엔티티를 반환하기 전에 1차캐시에 저장을 하고 엔티티를 반환한다.
    - 따라서 1차캐시에 없는 엔티티를 조회할 떄에 처음에는 DB를 조회하지만 2번째부턴 1차캐시에 있는걸 조회한다는 뜻이다.
- 엔티티의 동일성 보장
    - em.find(Member.class, member1)  을 2번해도 같은 1차캐시에 있는 것을 반환한다.
- 영속성 컨텍스트 안에는 1차캐시 이외에도 쓰기 지연 SQL 저장소가 있는 데 이것은 트랜잭션이 커밋되기 전까지 의 sql 문을 차곡차곡 쌓아놓고 트랜잭션이 커밋될 때 DB에 반영하면서 sql문들을 DB에 보내서 실행한다.
- 이렇게 하는 이유는 성능최적화 라고한다. 자세한 건 모름
- 변경감지
    - 변경감지는 update할 때에 일어나는 일인데 우리는 em.update() 이렇게 하지않고 setter로 엔티티만 변경하면 알아서 DB에 update된다.
    - 그 이유는 영속성 컨택스트에 1차캐시로 저장이 될 때 그 스냅샷을 찍어서 flush()를 실행할 때에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾기 때문이다.
    - 따라서 변경감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.
- 플러시
    - 플러시는 flush() 하거나 트랜잭션 커밋하거나 JPQL 실행시 자동호출된다.
    - 플러시로 인해 영속성 컨텍스트에 보관된 엔티티를 지운다고 생각하면 안된다. 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 것이 플러시다.
- 준영속
    - em.detach() 를 사용하면 sql 쓰기 지연 저장소 부터 1차캐시에 있는 정보가 모두 제거된다.
    - em.clear()는 영속석 컨텍스트에 있는 모든 데이터를 초기화 하고 안에 관리하고 있던 엔티티를 모두 준영속 상태로 만드는 것이다.
- 병합
    - merge() 하면 비영속이든 준영속이든 모두 영속상태로 만들 수 있다.
