## SQL 레벨업

### 1장 DBMS 아키텍처 개요 

1. 쿼리 평가 엔진
    * 사용자로부터 입력받은 SQL 구문을 분석하고, 어떤 순서로 기억장치의 데이터에 접근할지를 결정한다. 
    * 이것을 '실행 계획'이라고 부른다. 
    * 이러한 실행 계획에 기반을 둬서 데이터에 접근 하는 방법을 '접근 메서드' 라고 부른다. 
    * 쿼리라는 의미는 좁은 의미로는 Select 구문을 뜻하고, 큰 의미로는 SQL 구문 전체를 나타낸다. 
2. 버퍼 매니저
    * DBMS는 버퍼라는 특별한 용도로 사용하는 메모리 영역을 확보해둔다. 이 메모리 영역을 관리하는 것이 버퍼 매니저 이다. 
    * 버퍼 매니저는 디스크 용량 매니저와 함께 연동되어 작동한다. 
3. 디스크 용량 매니저   
    * 디스크 용량 매니저는 어디세 어떻게 데이터를 저장할지를 관리하며, 데이터의 읽고 쓰기를 제어한다. 
4. 트랜잭션 매니저와 락 매니저
    * 트랜잭션의 정합성을 유지하면서 실행시키고, 필요한 경우 데이터에 락을 걸어 다른 사람의 요청을 대기시키는 역할을 한다. 
5. 리커버리 매니저
    * DBMS가 저장하고 있는 데이터 중에는 절대 잃어버리면 안 되는 데이터가 있다. 하지만 시스템은 장애가 발생할 수 있다. 따라서 
    데이터를 정기적으로 백업하고, 문제가 일어났을 때 복구해줘야 하는데 이러한 기능을 수행하는 것이 리커버리 매니저이다. 

이 중에서 가장 중요한 건 쿼리 평가 엔진이다. 

### 2장 DBMS와 버퍼

* 1차 기억장치 : 메모리, 레지스터
* 2차 기억장치 : HDD, CD, DVD, 플래시 메모리 등
* 3차 기억장치 : 테이프

메모리를 영속적으로 저장하기 위하려면 속도를 잃고, 속도를 얻고자 하면 많은 데이터를 영속적으로 저장하기가 힘든 트레이드 오프가 발생한다. 

DBMS가 사용하는 기억장치들 : HDD, 메모리, 버퍼를 활용한 속도 향상
HDD
    * DBMS가 데이터를 저장하는 매체는 대부분 HDD이다. 
메모리  
    * 일반적인 데이터베이스 서버의 경우 탑재되는 메모리 양은 한두 자리 정도이다. 아무리 많다고 해도 100GB를 넘는 경우는 거의 없다. 
버퍼를 활용한 속도 향상
    * DBMS가 일부라도 데이터를 메모리에 올리는 것은 성능 향상 때문이다. 한마디로 SQL 구문의 실행 속도를 빠르게 만들기 위함이다. 
* 디스크 접근을 줄일 수 있다면 큰 폭의 성능 향상이 가능하다. 
* 일반적인 SQL 구문의 실행 시간 대부분을 저장소 I/O에 사용하기 때문이다. 
* 이렇게 성능 향상을 목적으로 데이터를 저장하는 메모리를 버퍼, 또는 캐시라고 부른다. 
* 이러한 고속 접근이 가능한 버퍼에 '데이터를 어떻게, 어느 정도의 기간 동안 올릴지'를 관리하는 것이 DBMS의 버퍼 매니저이다. 
* DBMS가 데이터를 유지하기 위해 사용하는 메모리는 크게 두 종류이다.
    * 데이터 캐시
    * 로그 버퍼
* 데이터 캐시 : 디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용하는 메모리 영역, 데이터베이스세계에는 '디스크를 건드리는 자는 불행해진다'라는 격언이 있다. 
* 로그 버퍼 : DBMS는 갱신과 관련된 SQL 구문을 사용자로부터 받으면, 로그 버퍼에 변경 정보를 보내고 이후 디스크에 변경을 수행한다. 
* 데이터베이스의 갱신 처리는 SQL 구문의 실행 시점과 저장소에 갱신하는 시점에 차이가 있는 비동기 처리이다. 

* 메모리의 특성 
    * 휘발성 : 서버가 죽거나, 프로세스 다운이 일어나면 메모리의 정보가 다 날아간다. 
* 데이터의 정합성과 성능의 트레이드 오프
    * 동기 처리 : 데이터 정합성 O , 성능 X
    * 비동기 처리 : 데이터 정합성 X, 성능 O

* 시스템 특성에 따른 트레이드오프
- 데이터 캐시와 로그 버퍼의 크기

* 로그 버퍼(갱신 처리)의 초기값이 데이터 캐시에 비해 작은 이유 : 데이터베이스가 기본적으로 검색을 메인으로 처리한다고 가정하기 때문
* 따라서 갱신 처리에 값비싼 메모리를 많이 사용하는 것 보다는, 자주 검색하는 데이터를 캐시에 올려놓는 것이 좋다고 생각합니다. 
* 데이터베이스는 메모리 부족 오류를 발생시켜 모든 처리를 중단시켜버리는 그런 선택을 하지않는다. 

* group by를 사용할 때에는 count(*)나 avg(*)를 같이 사용하자!!
ex ) select count(*) from survey_results_public group by Hobby;
     select count(*) from Address group by (); 

* 예를 들어 살고 있는 사람수가 한 명 뿐인 주소필드를 선택하고 싶다면 
    ex) select address, count(*) from address group by address having count(*)=1;
    
select survey_results_public.Country, count(*) from survey_results_public group by Country having count(*)=64;


