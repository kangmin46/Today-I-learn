# 힙
## 힙의 종류

1. 최대 힙
    - 부모 노드의 키 값의 크기가 자식 노드의 키 값의 크기보다 크거나 같은 경우
2. 최소 힙
    - 부모 노드의 키 값의 크기가 자식 노드의 키 값의 크기보다 작거나 같은 경우

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ef984d88-69a9-4601-9e22-0ca147236c5c/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ef984d88-69a9-4601-9e22-0ca147236c5c/Untitled.png)

## 힙의 구현

- 힙을 저장하는 표준 자료 구조는 배열이다.
- 구현을 쉽게 하기 위해서 인덱스 0은 사용하지 않고 1부터 시작한다.
- 노드의 위치는 불변
- 부모 인덱스  = 자식 인덱스 / 2
- 왼쪽 자식 인덱스 =  부모인덱스  *  2
- 오른쪽 자식 인덱스 = (부모 인덱스  *2) +1

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8156cd48-7099-431b-97cb-49ed054da5e8/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8156cd48-7099-431b-97cb-49ed054da5e8/Untitled.png)

## 힙의 삽입

- 일단 삽입이 되면 마지막 노드의 인덱스로 일단 채운다 그 값이 어떤 값이든 간에
- 그리고 부모 노드랑 계속 비교를 해서 최대 힙 기준 부모 노드가 새로 삽입되어 들어온 값보다 작으면 부모 노드랑 교체를 하면서 힙을 재구성하게 되는 것이다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d93e1bab-15f6-4268-bc0d-61921e04fc8c/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d93e1bab-15f6-4268-bc0d-61921e04fc8c/Untitled.png)

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b5ed996d-0a48-4381-bb3c-feef68e86bc2/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b5ed996d-0a48-4381-bb3c-feef68e86bc2/Untitled.png)

## 힙의 삭제

- 일단 최대 힙 기준 값이 최대인 부모노드를 삭제한다고 가정해 보자.
- 그러면 그 일단 부모 노드를 삭제를 한다.
- 그러면 부모 노드가 비어있을 테니까 그 부분을 누군가가 채워야 된다.
- 그런데 그 채우는 노드는 제일 마지막 노드가 그 부분을 채운다.
- 그리고 부모와 자식을 비교하면서 힙을 재구성 하게 된다.
- 그리고 자식과 비교할 때에 왼쪽 자식을 먼저 비교하게 된다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e0483eaa-2600-4ebe-93f1-be2f2272c204/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e0483eaa-2600-4ebe-93f1-be2f2272c204/Untitled.png)

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/853252d1-e74b-4bc4-bbec-10a540a01ead/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/853252d1-e74b-4bc4-bbec-10a540a01ead/Untitled.png)

- 우선 순위 큐는 간단하게 이야기 해서 가장 우선순위가 높은 데이터를 제일 먼저 꺼내는 방식이다. 데이터의 삽입 순서와 관계 없이

# 우선 순위 큐

## 우선 순위 큐의 구현 방법

- 배열
    - 배열에서는 삽입을 할 때에 데이터를 한 칸 씩 밀거나 당겨야 하는 상황이 발생한다.
    - 또한 배열은 크기가 정해져 있다.
    - 삽입할 때에 저장되어 있는 모든 데이터의 우선순위를 알아야 정렬을 할 수 있기 때문에 효율적이지 못하다.
- Linked List
    - 연결 리스트도 삽입할 때에 저장되어 있는 모든 데이터의 우선순위를 알아야 정렬을 할 수 있기 때문에 효율적이지 못하다.
- 힙
    - 힙은 우선 순위 큐를 구현하기에 가장 이상적이다.
    - 왜냐면 최대 힙, 최소 힙이라는 것이 존재한다.
    - 그리고 각 노드의 숫자가 우선 순위라고 한다면 최소 힙 기준 삽입을 하게 되면 힙에서의 삽입과 동일하고 앞서 배열이나 Linked List에서 모든 데이터의 우선 순위를 비교해야 됨과는 달리, 삽입된 위치의 부모 노드랑만 비교를 해서 위치를 바꿔주면서 힙을 재구성 하면 되기 때문이다.
    - 삭제는 훨씬 더 간단하다!
        - 삭제를 한다면 최소 힙 기준 제일 최소가 되는 데이터를 삭제하는 것이기 때문에 최소 힙에서의 최고 부모 노드를 삭제를 하면 되는 것이다.
        - 그러면 제일 마지막 인덱스를 최고 부모 노드로 옮기고 힙을 재구성하게 되면 삭제가 완료된다.
    - 힙을 구현할 때에 배열이나 Linked List중에서 하나를 이용해야 된다.
        - 그런데 Linked List는 새로운 노드를 힙의 마지막 위치에 추가하는 것이 상당히 번거롭고 힘들다. 하지만 배열은 이같은 문제가 전혀 없기 때문에 배열로 보통 구현한다.
- 매우 빠른 속도를 자랑하는 정렬 방법
    - 머지 소트와는 달리 리스트를 비균등하게 분할한다.
- 분할 정복(divide and conquer)
    - 문제를 작은 2개의 문제로 분리하고 각각 해결한 다음 결과를 모아서 원래의 문제를 해결하는 전략이다.
    - 분할 정복 방법은 대게 순환 호출을 이용하여 구현한다.
- 과정
    1. 리스트의 한 요소를 선택한다 이것을 피벗(Pivot)이라고 한다.
    2. 피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮겨지고 피벗보다 큰 요소들은 오른쪽으로 옮겨진다.
    3. 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다. 
        - 분할된 부분 리스트에 대하여 순환 호출을 이용하여 정렬을 반복한다.
        - 부분 리스트에서도 다시 피벗을 정하고 피벗을 기준으로 2개의 부분 리스트로 나누는 과정을 반복한다.
- 퀵 정렬의 구체적인 개념
    - 하나의 리스트를 피벗을 기준으로 두 개의 비균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법이다.
    - 퀵 정렬의 단계
        - 분할(Divide) : 입력 배열을 피벗을 기준으로 비균등하게 2개의 부분 배열(피벗을 중심으로 왼쪽 : 피벗보다 작은 요소들, 오른쪽 : 피벗보다 큰 요소들)로 분할한다.
        - 정복(Conquer) : 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출을 이용해 다시 분할 정복  방법을 적용
        - 결합(Combine) : 정렬된 부분 배열들을 하나의 배열에 합병한다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0e2ca13f-ef36-4563-b7e2-aec941d614e5/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0e2ca13f-ef36-4563-b7e2-aec941d614e5/Untitled.png)

# 퀵소트
- 매우 빠른 속도를 자랑하는 정렬 방법
    - 머지 소트와는 달리 리스트를 비균등하게 분할한다.
- 분할 정복(divide and conquer)
    - 문제를 작은 2개의 문제로 분리하고 각각 해결한 다음 결과를 모아서 원래의 문제를 해결하는 전략이다.
    - 분할 정복 방법은 대게 순환 호출을 이용하여 구현한다.
- 과정
    1. 리스트의 한 요소를 선택한다 이것을 피벗(Pivot)이라고 한다.
    2. 피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮겨지고 피벗보다 큰 요소들은 오른쪽으로 옮겨진다.
    3. 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다. 
        - 분할된 부분 리스트에 대하여 순환 호출을 이용하여 정렬을 반복한다.
        - 부분 리스트에서도 다시 피벗을 정하고 피벗을 기준으로 2개의 부분 리스트로 나누는 과정을 반복한다.
- 퀵 정렬의 구체적인 개념
    - 하나의 리스트를 피벗을 기준으로 두 개의 비균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법이다.
    - 퀵 정렬의 단계
        - 분할(Divide) : 입력 배열을 피벗을 기준으로 비균등하게 2개의 부분 배열(피벗을 중심으로 왼쪽 : 피벗보다 작은 요소들, 오른쪽 : 피벗보다 큰 요소들)로 분할한다.
        - 정복(Conquer) : 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출을 이용해 다시 분할 정복  방법을 적용
        - 결합(Combine) : 정렬된 부분 배열들을 하나의 배열에 합병한다.
        
- 퀵 소트의 특징
    - 장점
        - 속도가 빠르다.  O(nlogN)이며 다른 정렬 알고리즘과 비교해서 빠르다.
        - 추가 메모리 공간을 필요로 하지 않는다.
    - 단점
        - 정렬된 리스트에 대해서는 퀵 소트의 불균형 분할로 수행시간이 많이 걸린다.
- 퀵 소트의 시간복잡도
    - 최선의 경우

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9306e7cf-ae81-4082-81d2-835006b9278a/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9306e7cf-ae81-4082-81d2-835006b9278a/Untitled.png)

    - 순환 호출의 깊이
        - 레코드의 개수가 2의 거듭제곱일 경우 순환 호출의 깊이는 만약 2^3이 레코드 숫자라면 log3이된다.
        - 왜냐하면 2^3에서 2^2, 2이렇게 줄어들기 때문
        - 그리고 순환 호출안에서 이제 left , right를 나누어 비교를 해야되기 때문에 이것이 n번이다.
        - 따라서  O(nlogn) 이다.
    - 최악의 경우

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/eb5b85da-4748-45be-a1e2-9043dbe7e518/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/eb5b85da-4748-45be-a1e2-9043dbe7e518/Untitled.png)

    - 순환 호출의 깊이
        - 레코드의 개수가 2의 거듭제곱일 경우  n이 된다.
        - 순환 호출 안에서 또 left, right를 비교해야되니까 n번
        - 따라서 O(n^2)이다.